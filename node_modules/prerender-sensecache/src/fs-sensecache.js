const util          = require('../../../lib/util');
const senseCache    = require('./fs-cachemodule');
const fs            = require('node-fs');
let cacheConfig     = [];

module.exports = {

    init: function() {

        util.log(`[SenseCache] Sensemakers FS cache engine loaded!`);
        getConfig = function() {	

            const config = JSON.parse(fs.readFileSync('./config/cache.json', 'utf8'));
            cacheConfig = config.site;

            setTimeout(()=>{
                getConfig();
                if (config.verboseUpdate)
                    util.log(`[SenseCache] Updated sites with trailing slash`);
            }, ( ((config.updateTimer) * 1000)) );
        }
        getConfig();           
    },

    requestReceived: function(req, res, next) {

        if (req.method !== 'GET') {    // We only want to serve GET requests from cache (rendering our VueJS website for crawlers)            
            
            next();
        } else {

            if (req.prerender.url) {

                let hasTrailingSlash = false;
                cacheConfig.forEach((site) =>{                    
                    if ( req.prerender.url.includes(site) ) {
                        console.log('site: ', site, true);
                        hasTrailingSlash = true;
                    } else {
                        console.log('site: ', site, false);
                    }
                })

                if (!req.prerender.url.match(/\/$/) && hasTrailingSlash) {

                    util.log(`[SenseCache] Wrong URL received! It didn't end with a '/' not reading from cache: ${req.prerender.url}`);
                    next();
                } else {

                    senseCache.cache.read(req.prerender.url, function (error, byteStream) {
                    
                        const minLength     = process.env.CACHE_MIN_LENGTH || 4000;
                        let html            = ''+byteStream;
                        if (!error && html) {
    
                            if (html.length < minLength) {
    
                                senseCache.cache.remove(req.prerender.url);
                                req.prerender.senseCache = false;
                                next();
                            } else {
                                
                                // SEO snapshot fix
                                if (html.substr(0, 10) == 'html<html>') {
    
                                    util.log(`[SenseCache] Stored HTML for url '${req.prerender.url}' needed a small SEO correction`);
                                    html = html.substr(4);
                                }
    
                                req.prerender.senseCache = true;
                                util.log(`[SenseCache] Serving ${req.prerender.url} from cache (length: ${html.length})`);
                                res.send(200, html);
                            }
                        } else {
                            next();
                        }
                    });
                }            
            } else {
                next();
            }
        }
    },

    beforeSend: function(req, res, next) {

        if (!req.prerender.senseCache) {

            const minLength     = process.env.CACHE_MIN_LENGTH || 4000;
            const html          = req.prerender.content;
            if (req.prerender.statusCode == 200 && html.length > minLength) {

                util.log(`[SenseCache] Writing cache for ${req.prerender.url} ${html.length}`);
                senseCache.cache.write(req.prerender.url, html);                
            }
        }
        next();
    }
}