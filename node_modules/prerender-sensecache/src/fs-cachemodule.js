const fs        = require('node-fs');
const url       = require('url');
const os        = require('os');
const pathObj   = require('path');
const sanitize  = require('sanitize-filename');
const util      = require('../../../lib/util');

/**
 * Resolves the path where we'll cache the file
 * @param {string} requestUrl 
 */
const resolvePath = function(requestUrl) {
    
    const cachePath     = process.env.CACHE_ROOT_DIR || pathObj.join(os.tmpdir(), 'prerender-cache');
    const file          = process.env.CACHE_FILENAME || 'sensecache.html';
    const uri           = url.parse(requestUrl);
    let path            = `${cachePath}/${uri.host}`;

    if (uri.pathname && uri.pathname !== '/') {

        path = pathObj.join(path, pathObj.format(pathObj.parse(uri.pathname)));
        if (uri.query) {    // if a query is set, we'll also cache it
            path = pathObj.join(path, sanitize(uri.query));
        }
    }
    return { "path": path, "filename": file };
}

/**
 * async writes to file
 * @param {*} requestUrl 
 * @param {*} html 
 * @param {*} cb 
 */
const writeCache = function(requestUrl, html, cb) {
    
    const path = resolvePath(requestUrl);    
    const wcb = function(output) {} // Silence, writing takes place async.

    fs.exists(path.path, function(exists) {

        function fsWrite(output) { 

            const file = pathObj.join(path.path, path.filename);
            fs.writeFile(file, html, wcb);
        }
        if (exists === false) {     // create directory, write on callback
            fs.mkdir(path.path, {recursive: true, mode: '0777'}, fsWrite);
        } else {                    // directory exists, just write
            fsWrite();  
        }
    });
}

const readCache = function(requestUrl, cb) {
    
    const lifeTime  = (process.env.CACHE_LIFE_TIME * 60 * 60) || 36000;
    const path      = resolvePath(requestUrl);
    const file      = pathObj.join(path.path, path.filename);

    fs.exists(file, (exists) => {
        if (exists === false) {
            return cb(false, null);
        }
        
        // const readCb = (cacheFile) => {
        function readCb(error, cacheFile) {

            const date = new Date();
            const time = cacheFile.mtime.getTime();
            if ( (date.getTime() - time) > (lifeTime * 1000) ) {
                return cb(false, null);
            }
            fs.readFile(file, cb);
        };
        fs.stat(file, readCb);
    });
}

const revokeCache = function(requestUrl) {
 
    const path      = resolvePath(requestUrl);
    const file      = pathObj.join(path.path, path.filename);

    fs.exists(file, (exists) => {

        if (exists) {
            function ucb(error, output) {
            
                util.log(`[SenseCache] Removed cache for: ${requestUrl}`);
            }
            fs.unlink(file, ucb);
        }
    });
}

module.exports = {

    resolvePath: resolvePath,
    writeCache: writeCache,
    readCache: readCache,
    revokeCache: revokeCache,

    /**
     * functions
     */
    cache: {
        read:   readCache,
        write:  writeCache,
        remove: revokeCache
    }
}